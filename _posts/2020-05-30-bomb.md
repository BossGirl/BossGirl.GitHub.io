---
layout: post
title: "day6 总结"
date:  2020-06-04 14:58:44
description: "day6"
tag: 总结
---

## Day6

> 毕设快要检查了，搞毕设去了先停一下解题，再补一补汇编语言，在此处更新笔记

#### 汇编指令后缀

```
对于访问一个字节数据类型，后缀是b。
对于访问两个字节数据类型，后缀是w。
对于访问四个字节数据类型，后缀是l。
```

## Day5

> 今天有别的事，就只做了第二关

### bomb_chall-phase2

查看此部分中调用的`read_six_numbers`函数

```
(gdb) disassemble read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x0804916c <+0>:	sub    $0x2c,%esp
   0x0804916f <+3>:	mov    0x34(%esp),%eax
   0x08049173 <+7>:	lea    0x14(%eax),%edx
   0x08049176 <+10>:	mov    %edx,0x1c(%esp)
   0x0804917a <+14>:	lea    0x10(%eax),%edx
   0x0804917d <+17>:	mov    %edx,0x18(%esp)
   0x08049181 <+21>:	lea    0xc(%eax),%edx
   0x08049184 <+24>:	mov    %edx,0x14(%esp)
   0x08049188 <+28>:	lea    0x8(%eax),%edx
   0x0804918b <+31>:	mov    %edx,0x10(%esp)
   0x0804918f <+35>:	lea    0x4(%eax),%edx
   0x08049192 <+38>:	mov    %edx,0xc(%esp)
   0x08049196 <+42>:	mov    %eax,0x8(%esp)
   0x0804919a <+46>:	movl   $0x804a323,0x4(%esp)
   0x080491a2 <+54>:	mov    0x30(%esp),%eax
   0x080491a6 <+58>:	mov    %eax,(%esp)
   0x080491a9 <+61>:	call   0x8048860 <__isoc99_sscanf@plt>
   0x080491ae <+66>:	cmp    $0x5,%eax
   0x080491b1 <+69>:	jg     0x80491b8 <read_six_numbers+76>
   0x080491b3 <+71>:	call   0x8049145 <explode_bomb>
   0x080491b8 <+76>:	add    $0x2c,%esp
   0x080491bb <+79>:	ret    
End of assembler dump.
```

对phase2分析

```c
(gdb) disassemble phase_2
Dump of assembler code for function phase_2:
   0x08048bb4 <+0>:	push   %esi
   0x08048bb5 <+1>:	push   %ebx
   0x08048bb6 <+2>:	sub    $0x34,%esp
   0x08048bb9 <+5>:	lea    0x18(%esp),%eax
   0x08048bbd <+9>:	mov    %eax,0x4(%esp)
   0x08048bc1 <+13>:	mov    0x40(%esp),%eax
   0x08048bc5 <+17>:	mov    %eax,(%esp)
   0x08048bc8 <+20>:	call   0x804916c <read_six_numbers>
	//由函数名可以看出要求输入六个数字。以上部分结束后，%esp即为输入的第一个数字的地址
   ------------------------------分割线---------------------------------  
   0x08048bcd <+25>:	cmpl   $0x0,0x18(%esp)	//判断输入是否为0
   0x08048bd2 <+30>:	jne    0x8048bdb <phase_2+39>
   0x08048bd4 <+32>:	cmpl   $0x1,0x1c(%esp)	//判断输入是否为1
   0x08048bd9 <+37>:	je     0x8048bfa <phase_2+70>
   0x08048bdb <+39>:	call   0x8049145 <explode_bomb>	
   0x08048be0 <+44>:	jmp    0x8048bfa <phase_2+70>
   //je表示如果被比较的两项（进行减操作）得到的结果是0，即$0x1与0x1c(%esp)的值相等，就跳转到0x8048bfa行，否则跳到0x8049145行执行爆破
   ------------------------------分割线---------------------------------  
   0x08048be2 <+46>:	mov    -0x8(%ebx),%eax 
   0x08048be5 <+49>:	add    -0x4(%ebx),%eax  
   0x08048be8 <+52>:	cmp    %eax,(%ebx)
   //此处逻辑为：n[i]=n[i-1]+n[i-2]
   0x08048bea <+54>:	je     0x8048bf1 <phase_2+61>
   0x08048bec <+56>:	call   0x8049145 <explode_bomb>
   //将第一位和第二位数字加起来与第三位数字进行比较，相等为1，不等跳转炸弹
   ------------------------------分割线---------------------------------  
   0x08048bf1 <+61>:	add    $0x4,%ebx
   0x08048bf4 <+64>:	cmp    %esi,%ebx
   0x08048bf6 <+66>:	jne    0x8048be2 <phase_2+46>
   0x08048bf8 <+68>:	jmp    0x8048c04 <phase_2+80>
   0x08048bfa <+70>:	lea    0x20(%esp),%ebx
   这里是一个循环，循环3次，循环内跳转到phase_2+46
   ------------------------------分割线---------------------------------
   0x08048bfe <+74>:	lea    0x30(%esp),%esi
   0x08048c02 <+78>:	jmp    0x8048be2 <phase_2+46>
   0x08048c04 <+80>:	add    $0x34,%esp
   0x08048c07 <+83>:	pop    %ebx
   0x08048c08 <+84>:	pop    %esi
   0x08048c09 <+85>:	ret    
End of assembler dump.
```

综上可知，这六个数具有第一个为0，第二个为1，之后每个数为前一个和前两个值的和。

可以推出flag：`0 1 1 2 3 5 `

## Day4

今天关于二进制主要学了gdb的x命令

x为examine的简写，用来查看内存地址中的值。

```c
x/<n/f/u> <addr> 	//n、f、u是可选参数
```

**n**表示需要显示的内存单元的个数，即从当前地址向后显示及格内存单元的内容，一个内存单元的大小由后面的u定义。

**f**表示显示的格式

```
s-字符串
i-指令地址
```

**u**表示从当前地址往后请求的字节数，默认为4bytes，该参数可以用下面的字符来代替。当指定字节长度后，gdb会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来

```
b-单字节
h-双字节
w-四字节
g-八字节
```

**输出格式：**一般gdb会根据变量的类型输出变量的值，但我们也可以自定义gdb的输出格式。（例如你想输出一个整数的十六进制，或是二进制来查看这个整型变量中的位情况）

```
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 无符号十进制
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
```

还有这篇文章，没来的及做笔记，明天补上

[https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://introspelliam.github.io/2017/08/03/pwn/gdb的调试与使用/)



## Day3

今天白天啥都没干，光整体检的事儿了...体检的医院离我家真的好远T T

晚上继续写毕设



## Day2

今天主要学了汇编语言入门，包括寄存器、堆栈、CPU指令。

### 寄存器

​	CPU本身只负责运算，不负责存储数据，数据存在内存之中。但是CPU的运算速度远高于内存的读写速度，因此CPU自带一级缓存和二级缓存。由于CPU缓存不够快且数据在缓存里面的地址不是固定的导致CPU每次读写都要寻址，因此CPU还自带了寄存器，用来存储最常用的数据，即哪些最频繁读写的数据例如循环变量都会放在寄存器里，CPU优先读写寄存器，再由寄存器跟内存交换数据。

### 堆

程序运行时，操作系统会给它分配一段内存，用来存储程序和运行产生的数据。

由于用户主动请求而划分出来的内存区域叫做堆由起始地址开始，从低位向高位增长，堆必须手动释放或由垃圾回收机制来回收。

### 栈

栈是由于函数运行而临时占用的内存区域，后进先出。

### example

```c
int add_a_and_b(int a, int b) {
   return a + b;
}
int main() {
   return add_a_and_b(2, 3);
}
```

对应的汇编语言为：

```c
_add_a_and_b:
   push   %ebx			//将寄存器EBX里面的值写入_add_a_and_b函数
   mov    %eax, [%esp+8] //将ESP寄存器里面的地址加上8个字节，按照这个地址在栈中取出数据，并将数据写入EAX寄存器
   mov    %ebx, [%esp+12] //将ESP寄存器里面的地址加上12个字节...
   add    %eax, %ebx 
   pop    %ebx //取出EBX寄存器的原始值，并将这个值写回EBX寄存器
   ret  

_main:
   push   3			//将运算子3入栈
   push   2			//将运算子2入栈
   call   _add_a_and_b 			//调用_add_a_and_b函数
   add    %esp, 8
   ret
```

`push   %ebx`中，push为CPU指令，%ebx是该指令要用到的运算子，一个CPU指令可以用有0～多个运算子。

`push`指令用于将运算子入栈

`call`指令用来调用函数

`mov`指令用于将一个值写入某个寄存器

`add`指令用于将两个运算子相加，并将结果写入第一个运算子

`pop`指令用于取出栈最低位的值，并将这个值写入运算子指定的位置。另外，pop指令还会将ESP寄存器里面的地址加4，即回收4个字节

`ret`指令用于终止当前函数的执行，将运行权交还给上层函数，也就是当前函数的帧将被回收，该指令没有运算子。



## Day1

> 上午和下午做毕设，晚上想尝试做一下这个题的，但是程序运行就报错，查了好久才知道咋回事，装完这仨就好了。终于运行起来...哭
>
> apt-get install ia32-libs-multiarch
>
> apt-get install lib32ncurses5
>
> apt-get install lib32z1

### bomb_chall-phase1

这一关表哥给的pdf里面有写，跟着做就行了，对照汇编语言查各个指令的意思

```c++
08048b90 <phase_1>:
 8048b90:	83 ec 1c             	sub    $0x1c,%esp			
 8048b93:	c7 44 24 04 64 a1 04 	movl   $0x804a164,0x4(%esp)			
 8048b9a:	08 
 8048b9b:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048b9f:	89 04 24             	mov    %eax,(%esp)
 8048ba2:	e8 93 04 00 00       	call   804903a <strings_not_equal>
 8048ba7:	85 c0                	test   %eax,%eax
 8048ba9:	74 05                	je     8048bb0 <phase_1+0x20>
 8048bab:	e8 95 05 00 00       	call   8049145 <explode_bomb>
 8048bb0:	83 c4 1c             	add    $0x1c,%esp
 8048bb3:	c3                   	ret   
```

由以上代码得到：将0x804a164中的内容移动到0x4(%esp)中；读入的字符串移动到%eax中，在call字符串比较函数中进行比较，当相等的时候正常运行，不相等的时候call explode_bomb函数，故得到phase1正确输出的字符串的内容为0x804a164中的内容。

​	使用gdb在phase1处设置断点，然后查看0x804a164中的内容，得到如下内容，run后输入内容，正确。

<img src="/images/oj_wp/image-20200530234518288.png" alt="image-20200530234518288" style="zoom: 33%;" />



