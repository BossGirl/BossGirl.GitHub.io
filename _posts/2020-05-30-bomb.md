---
layout: post
title: "day4 总结"
date:  2020-06-02 14:58:44
description: "day4"
tag: 总结
---

## Day4

今天关于二进制主要学了gdb的x命令

x为examine的简写，用来查看内存地址中的值。

```c
x/<n/f/u> <addr> 	//n、f、u是可选参数
```

**n**表示需要显示的内存单元的个数，即从当前地址向后显示及格内存单元的内容，一个内存单元的大小由后面的u定义。

**f**表示显示的格式

```
s-字符串
i-指令地址
```

**u**表示从当前地址往后请求的字节数，默认为4bytes，该参数可以用下面的字符来代替。当指定字节长度后，gdb会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来

```
b-单字节
h-双字节
w-四字节
g-八字节
```

**输出格式：**一般gdb会根据变量的类型输出变量的值，但我们也可以自定义gdb的输出格式。（例如你想输出一个整数的十六进制，或是二进制来查看这个整型变量中的位情况）

```
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 无符号十进制
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
```

还有这篇文章，没来的及做笔记，明天补上

[https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://introspelliam.github.io/2017/08/03/pwn/gdb的调试与使用/)



## Day3

今天白天啥都没干，光整体检的事儿了...体检的医院离我家真的好远T T

晚上继续写毕设



## Day2

今天主要学了汇编语言入门，包括寄存器、堆栈、CPU指令。

### 寄存器

​	CPU本身只负责运算，不负责存储数据，数据存在内存之中。但是CPU的运算速度远高于内存的读写速度，因此CPU自带一级缓存和二级缓存。由于CPU缓存不够快且数据在缓存里面的地址不是固定的导致CPU每次读写都要寻址，因此CPU还自带了寄存器，用来存储最常用的数据，即哪些最频繁读写的数据例如循环变量都会放在寄存器里，CPU优先读写寄存器，再由寄存器跟内存交换数据。

### 堆

程序运行时，操作系统会给它分配一段内存，用来存储程序和运行产生的数据。

由于用户主动请求而划分出来的内存区域叫做堆由起始地址开始，从低位向高位增长，堆必须手动释放或由垃圾回收机制来回收。

### 栈

栈是由于函数运行而临时占用的内存区域，后进先出。

### example

```c
int add_a_and_b(int a, int b) {
   return a + b;
}
int main() {
   return add_a_and_b(2, 3);
}
```

对应的汇编语言为：

```c
_add_a_and_b:
   push   %ebx			//将寄存器EBX里面的值写入_add_a_and_b函数
   mov    %eax, [%esp+8] //将ESP寄存器里面的地址加上8个字节，按照这个地址在栈中取出数据，并将数据写入EAX寄存器
   mov    %ebx, [%esp+12] //将ESP寄存器里面的地址加上12个字节...
   add    %eax, %ebx 
   pop    %ebx //取出EBX寄存器的原始值，并将这个值写回EBX寄存器
   ret  

_main:
   push   3			//将运算子3入栈
   push   2			//将运算子2入栈
   call   _add_a_and_b 			//调用_add_a_and_b函数
   add    %esp, 8
   ret
```

`push   %ebx`中，push为CPU指令，%ebx是该指令要用到的运算子，一个CPU指令可以用有0～多个运算子。

`push`指令用于将运算子入栈

`call`指令用来调用函数

`mov`指令用于将一个值写入某个寄存器

`add`指令用于将两个运算子相加，并将结果写入第一个运算子

`pop`指令用于取出栈最低位的值，并将这个值写入运算子指定的位置。另外，pop指令还会将ESP寄存器里面的地址加4，即回收4个字节

`ret`指令用于终止当前函数的执行，将运行权交还给上层函数，也就是当前函数的帧将被回收，该指令没有运算子。



## Day1

> 上午和下午做毕设，晚上想尝试做一下这个题的，但是程序运行就报错，查了好久才知道咋回事，装完这仨就好了。终于运行起来...哭
>
> apt-get install ia32-libs-multiarch
>
> apt-get install lib32ncurses5
>
> apt-get install lib32z1

### bomb_chall-phase1

这一关表哥给的pdf里面有写，跟着做就行了，对照汇编语言查各个指令的意思

```c++
08048b90 <phase_1>:
 8048b90:	83 ec 1c             	sub    $0x1c,%esp			
 8048b93:	c7 44 24 04 64 a1 04 	movl   $0x804a164,0x4(%esp)			
 8048b9a:	08 
 8048b9b:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048b9f:	89 04 24             	mov    %eax,(%esp)
 8048ba2:	e8 93 04 00 00       	call   804903a <strings_not_equal>
 8048ba7:	85 c0                	test   %eax,%eax
 8048ba9:	74 05                	je     8048bb0 <phase_1+0x20>
 8048bab:	e8 95 05 00 00       	call   8049145 <explode_bomb>
 8048bb0:	83 c4 1c             	add    $0x1c,%esp
 8048bb3:	c3                   	ret   
```

由以上代码得到：将0x804a164中的内容移动到0x4(%esp)中；读入的字符串移动到%eax中，在call字符串比较函数中进行比较，当相等的时候正常运行，不相等的时候call explode_bomb函数，故得到phase1正确输出的字符串的内容为0x804a164中的内容。

​	使用gdb在phase1处设置断点，然后查看0x804a164中的内容，得到如下内容，run后输入内容，正确。

<img src="/images/oj_wp/image-20200530234518288.png" alt="image-20200530234518288" style="zoom: 33%;" />



